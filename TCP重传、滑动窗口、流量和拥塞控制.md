# TCP重传、滑动窗口、流量和拥塞控制

## 1.重传机制

### 1.1超时重传

在发送数据包时，设置一个定时器，如果超过这个时间还未收到接收端的ACK就重传这个数据，因此，如果应答包丢失或者数据包本身丢失都会引起超时

问题就变成了这个超时重传的时间（retransmission timeout）RTO应该设置为多少？可以确认的是：这个时间不能太长或者太短，太长会导致丢失的包迟迟不能重传，效率低下；而太短的时间又会导致一个本没有丢失的包触发超时。这个时间应该设置地比RTT（往返时延）略长

设置一个比RTT略长的时间看似很具体，实则很抽象，在复杂多变的网络环境中，RTT并不是不变的，因此伴随着RTO也要随时变化，linux使用以下方式计算RTT：

```
1.一个样本RTT(sampleRTT)是从一个报文被段被发送到该报文段的确认被接收的时间，大多仅在某一个时刻做一次sampleRTT的测量
2.同时维持一个均值RTT（EstimatedRTT），每当得到一个新的sampleRTT，就会使用如下公式计算新的EstimatedRTT：
	EstimatedRTT = (1 - α) * EstimatedRTT + α * sampleRTT（其中α的推荐值为0.125）
3.RTT偏差值DevRTT，用于计算sampleRTT一般会偏离EstimatedRTT的程度：
	DevRTT = (1 - β) * DevRTT + β * (|SampleRTT - EstimatedRTT|)（β推荐值为0.25）
4.RTO被设置为EstimatedRTT加上一个余量：
	RTO = EstimatedRTT + 4 * DevRTT
推荐初始的RTO为1秒，如果出现超时就加倍，当收到确认报文段得到新的EstimatedRTT就按照公式进行计算
```

### 1.2快速重传

快速重传机制比较简单：当发送端收到三个相同的ACK报文段时就在触发超时之前重传。比如：

- 发送端发送了1~4的四个报文段，但是第二个报文段没收到，那么接收端会检查序列号，持续返回第二个的ACK（ACK表示的是接下来希望收到的数据起始点），那么分别会在第1、3、4报文段到达时确认报文段2，此时发送端就会触发重传

一个问题：应该重传一个还是之后的所有？比如上述例子，是应该仅仅重传2号报文段还是及其之后的一起？为了解决这个问题，有了SACK（selective acknowledgment）选择确认方法，当出现三次重复的ACK时，可以在TCP头部中选项字段中添加SACK将接收的缓存地图发送给发送端，发送端查看这个地图就可以知道哪些报文没收到，选择重传没收到的即可

另外还有一个D-SACK(Duplicate SACK)用于告诉发送方哪些数据被重复接收：

- 如果ACK确认号大于了（或者等于）SACK范围中的最大值，说明这个SACK是一个D-SACK，是告诉发送方范围内的数据被重复接收，于是便有了以下好处：发送方知道具体是自己的包丢失了还是应答包丢失了；可以知道发送方的包是否被网络延迟了；可以知道发送方的包是否被网络复制了

## 2.滑动窗口

接收一个确认一个的模式效率不够高，于是引入了滑动窗口的概念：即只要在发送窗口内发送的数据，发送方可以不用等待确认应答的到来接着发送数据。于是这个窗口的值就是不用等待ACK能一直发送数据的最大值。

累计确认/累计应答：这个滑动窗口带来的一个好处，比如当中间的某个ACK报文丢失时，按照以往是还等重传这个报文段，但是有了滑动窗口的大量数据发送，这个ACK之后的数据也照常收到了，那么当发送一个更大的ACK时就可覆盖之前丢失的ACK，避免重传。

TCP头部中有一个window的字段用于告诉发送方自己接收处理数据的缓冲区大小。

对于发送方的整个需要发送的数据可以被逻辑上分为四个区域：<u>已发送并已确认，已发送但未确认，未发送但是还在接收方的处理范围内，未发送且超出了接收方的处理能力</u>。发送窗口的大小是从<u>已发送未确认的第一个字节开始到接收方处理范围的最后一个字节结束</u>。这四个区域的程序表示：

```
三个指针：SND.WND,SND.UNA,SND.NXT分别表示发送窗口的大小、第一个未确认报文段的序列号、下一个可以发送的报文段序列号。于是：
	可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)
```

![image-20221004114034775](C:\Users\邓强\AppData\Roaming\Typora\typora-user-images\image-20221004114034775.png)

而对于接收方则逻辑上可以将接收数据分为是三个部分：已接收且已确认，未接收并且在窗口范围内、未接收且不在窗口范围内，程序表示为：

```
两个指针：RCV.WND,RCV.NXT分别表示接收窗口的大小，下一个可接收的字节的序列号。
```

![image-20221004114533989](C:\Users\邓强\AppData\Roaming\Typora\typora-user-images\image-20221004114533989.png)

那么随着接收方的数据处理，窗口会逐渐往右移动，并更新窗口的大小告知发送方，发送方根据更新的窗口大小调整发送窗口范围以此达成了协调发送的能力

## 3.流量控制

发送方根据接收方实际接收能力控制发送的数据量即所谓流量控制

具体过程的概述：

- 双方在建立TCP连接的时候就会互相通告自己的窗口大小
- 接收方接收到数据就把RCV.NXT向右移动对应数据大小，并更新自己的RCV.WND大小
- 发送方则根据接收方通告的接收窗口大小发送数据，当收到ACK时将SND.NXT、SND.UNA向右移动，调整新的SND.WND大小

接收方和发送方的数据字节都是存放在操作系统的缓冲区的，这个缓冲区会受操作系统调控

为防止数据丢失，TCP不允许同时手收缩窗口又减少缓存，应该先收缩窗口，过段时间减少缓存

### 3.1窗口关闭

当接收方通告自己的可用窗口为0时就出现了窗口关闭，此时会阻止发送方再发送数据，同时可能会引发一个问题：<u>当发送方知道接收方的可用窗口大小为0时不再发送数据，但是过段时间之后接收方处理完数据又更新窗口大小的时候丢包了，这就可能让双方进入各自等待对方的局面，形成死锁。</u>

解决死锁问题：发送方设定定时器，当收到接收方可用窗口为0的信息时启动定时器，到时间之后发送一个窗口的探测报文，如果还是0那么重新计时。有的TCP连接会在重复上述过程3次之后发送RST错误报文中断连接

### 3.2糊涂窗口综合征

接收方实在太繁忙，导致缓冲区一直未能即使处理，那么就会引起发送窗口越来越小，最后甚至只有几个字节。而发送方又很轴，几个字节的空间都要发送，甚至数据的大小没有头部字段大，这就造成了巨大浪费

解决方案：

#### 3.2.1发送方不发送小数据

Nagle算法，满足以下条件之一才能发送数据

- 发送的数据要大于等于MSS或者剩余窗口的大小大于等于MSS
- 收到了上一个发送数据的ACK报文

这个算法不适合一些小数据发送的情况，需要手动关闭

#### 3.2.2接收方不通告小窗口

只有当窗口大小大于等于min(MSS,缓冲区/2)时才通告窗口，否则一律报0

## 4.拥塞控制

不同于流量控制，拥塞控制是为了防止发送方的数据填满整个网络（前者是为了防止发送方的数据填满接收方的窗口），当网络拥堵的时候，发送方会调节数据发送量，因此又有一个称为拥塞窗口（cwnd）的概念

cwnd可能影响swnd，自此，swnd = min(cwnd , rwnd)，当网络拥塞时cwnd减小，反之增大。判断是否拥塞：是否出现超时

拥塞控制的算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

### 4.1慢启动

大体规则：发送方在cwnd < ssthresh（慢启动门限slow start threshhold）每次收到一个ACK就将cwnd增大1倍，也就是2的指数级增长，当cwnd >= ssthresh时启动拥塞避免算法

### 4.2拥塞避免

大体思路：当达到ssthresh的时候，每次收到一个ACK就增加1/cwnd个字节，就是说每收到当前cwnd个ACK才增加一个字节的cwnd大小

到目前为止，cwnd还处在增长阶段，只是拥塞避免启动之后增长速率变慢了，如果不考虑rwnd和信道带宽的限制，增长到一定值会发生丢包引起重传，于是进入拥塞发生

### 4.3拥塞发生

此时有两个处理重传的算法：

- 发生超时时引发超时重传：此时将ssthresh设置为cwnd/2，cwnd置1，之后重新开始慢启动，网速出现断崖式下降，此种方式很容易造成卡顿
- 收到3个相同ACK时引发快速重传：此时cwnd = cwnd/2，ssthresh = cwnd，同时进入快速恢复

### 4.4快速恢复

快速恢复认为能够收到3个相同的ACK说明此时网络不那么糟，进入快速恢复的算法：

- 重传丢失的数据
- 如果再收到相同的ACK就将cwnd + 1
- 收到新的数据的ACK确认那么将cwnd设置为ssthresh + 3（3表示已经收到3个数据包），认定为已恢复，之后进入拥塞避免
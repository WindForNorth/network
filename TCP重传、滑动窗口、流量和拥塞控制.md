# TCP重传、滑动窗口、流量和拥塞控制

## 1.重传机制

### 1.1超时重传

在发送数据包时，设置一个定时器，如果超过这个时间还未收到接收端的ACK就重传这个数据，因此，如果应答包丢失或者数据包本身丢失都会引起超时

问题就变成了这个超时重传的时间（retransmission timeout）RTO应该设置为多少？可以确认的是：这个时间不能太长或者太短，太长会导致丢失的包迟迟不能重传，效率低下；而太短的时间又会导致一个本没有丢失的包触发超时。这个时间应该设置地比RTT（往返时延）略长

设置一个比RTT略长的时间看似很具体，实则很抽象，在复杂多变的网络环境中，RTT并不是不变的，因此伴随着RTO也要随时变化，linux使用以下方式计算RTT：

```
1.一个样本RTT(sampleRTT)是从一个报文被段被发送到该报文段的确认被接收的时间，大多仅在某一个时刻做一次sampleRTT的测量
2.同时维持一个均值RTT（EstimatedRTT），每当得到一个新的sampleRTT，就会使用如下公式计算新的EstimatedRTT：
	EstimatedRTT = (1 - α) * EstimatedRTT + α * sampleRTT（其中α的推荐值为0.125）
3.RTT偏差值DevRTT，用于计算sampleRTT一般会偏离EstimatedRTT的程度：
	DevRTT = (1 - β) * DevRTT + β * (|SampleRTT - EstimatedRTT|)（β推荐值为0.25）
4.RTO被设置为EstimatedRTT加上一个余量：
	RTO = EstimatedRTT + 4 * DevRTT
推荐初始的RTO为1秒，如果出现超时就加倍，当收到确认报文段得到新的EstimatedRTT就按照公式进行计算
```

### 1.2快速重传

快速重传机制比较简单：当发送端收到三个相同的ACK报文段时就在触发超时之前重传。比如：

- 发送端发送了1~4的四个报文段，但是第二个报文段没收到，那么接收端会检查序列号，持续返回第二个的ACK（ACK表示的是接下来希望收到的数据起始点），那么分别会在第1、3、4报文段到达时确认报文段2，此时发送端就会触发重传

一个问题：应该重传一个还是之后的所有？比如上述例子，是应该仅仅重传2号报文段还是及其之后的一起？为了解决这个问题，有了SACK（selective acknowledgment）选择确认方法，当出现三次重复的ACK时，可以在TCP头部中选项字段中添加SACK将接收的缓存地图发送给发送端，发送端查看这个地图就可以知道哪些报文没收到，选择重传没收到的即可

另外还有一个D-SACK(Duplicate SACK)用于告诉发送方哪些数据被重复接收：

- 如果ACK确认号大于了（或者等于）SACK范围中的最大值，说明这个SACK是一个D-SACK，是告诉发送方范围内的数据被重复接收，于是便有了以下好处：发送方知道具体是自己的包丢失了还是应答包丢失了；可以知道发送方的包是否被网络延迟了；可以知道发送方的包是否被网络复制了

## 2.滑动窗口

接收一个确认一个的模式效率不够高，于是引入了滑动窗口的概念：即只要在发送窗口内发送的数据，发送方可以不用等待确认应答的到来接着发送数据。于是这个窗口的值就是不用等待ACK能一直发送数据的最大值。

累计确认/累计应答：这个滑动窗口带来的一个好处，比如当中间的某个ACK报文丢失时，按照以往是还等重传这个报文段，但是有了滑动窗口的大量数据发送，这个ACK之后的数据也照常收到了，那么当发送一个更大的ACK时就可覆盖之前丢失的ACK，避免重传。

TCP头部中有一个window的字段用于告诉发送方自己接收处理数据的缓冲区大小。

对于发送方的整个需要发送的数据可以被逻辑上分为四个区域：<u>已发送并已确认，已发送但未确认，未发送但是还在接收方的处理范围内，未发送且超出了接收方的处理能力</u>。发送窗口的大小是从<u>已发送未确认的第一个字节开始到接收方处理范围的最后一个字节结束</u>。这四个区域的程序表示：

```
三个指针：SND.WND,SND.UNA,SND.NXT分别表示发送窗口的大小、第一个未确认报文段的序列号、下一个可以发送的报文段序列号。于是：
	可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)
```

![image-20221004114034775](C:\Users\邓强\AppData\Roaming\Typora\typora-user-images\image-20221004114034775.png)

而对于接收方则逻辑上可以将接收数据分为是三个部分：已接收且已确认，未接收并且在窗口范围内、未接收且不在窗口范围内，程序表示为：

```
两个指针：RCV.WND,RCV.NXT分别表示接收窗口的大小，下一个可接收的字节的序列号。
```

![image-20221004114533989](C:\Users\邓强\AppData\Roaming\Typora\typora-user-images\image-20221004114533989.png)

那么随着接收方的数据处理，窗口会逐渐往右移动，并更新窗口的大小告知发送方，发送方根据更新的窗口大小调整发送窗口范围以此达成了协调发送的能力
## 一、https如何优化

### 1.https的性能损耗

- TLS握手过程
- 握手之后报文的对称加密过程

### 2.硬件优化

- 针对https是计算密集型，使用参数更好的CPU就会加快速度
- 选择支持AES_NI的CPU，这种CPU专门针对传输报文过程的对称加密AES做了指令级优化

### 3.软件优化

- 软件升级
- 协议优化

### 4.协议优化

- 将秘钥协商算法从RSA替换为ECDHE算法，前者在密文传输之前需要4次握手，后者在第四次握手之前可以进行密文发送了
- TLS升级：TLS1.2升级为TLS1.3，可以大幅简化握手过程，只需要一个RTT。传统的4次握手前两次主要用于协商使用的加密算法，后两次由于交换公钥；而TLS1.3将两次进行合并，使得只需要一个RTT就能完成TLS握手，具体合并方式：客户端在第一次hello报文里携带了自己支持的所有椭圆及其公钥，服务器只需要从中进行选择，然后计算出自己的公钥发送给客户端，至此就完成了计算会话秘钥的所有数据交换。而且TLS1.3密码套件废除了RSA、DH等不支持前向保密的秘钥交换算法，而对于对称加密和签名算法也只支持寥寥数种

### 5.证书优化

- 采用ECDHE证书，而非传统的RSA证书（前者的秘钥更短）
- 证书验证优化：逐级验证是很繁琐浪费时间的过程，涉及到与CA建立网络连接，下载和查找CRL数据等，采用OCSP（在线证书状态协议）进行查询，就可以不用去下载CRL数据和查询了，而且更有实时性。OCSP stapling要求服务器向CA周期性地查询证书的状态，生成具有时间戳和签名的结果缓存，在客户端发起连接请求时将这个结果发送给客户，这样客户端就不用自己去向CA查询证书的有效性了

### 6.会话复用

简单来讲就是将第一TLS握手建立的会话秘钥在之后建立https时再次使用，就省去了TLS重新协商秘钥的过程，会话复用分为两种：

- session ID：在首次产生会话秘钥之后，客户端和服务器会用唯一的session ID来标识这个秘钥，待下一次客户端发起连接时，服务器再内存中根据这个ID查询秘钥存在，即可直接使用。这个秘钥在内存中会定期失效，还存在以下问题：1）服务器要保存那么巨大的秘钥数量，内存压力大；2）在均衡负载的情况下，客户端很可能不会两次请求到同一个服务器
- session Ticket：服务器不再缓存每个客户端的会话密钥，⽽是把缓存的⼯ 作交给了客户端。首次产生了会话秘钥之后，服务器将会话秘钥作为一个Ticket发送给客户端，客户端缓存；待下一次建立连接时，客户端加密Ticket发送给服务器，服务器解密得到会话秘钥，检查时效性，有效就继续使用。TLS1.3把Ticket一并放在了第一请求连接的报文里，使得重连只需要0RTT
- 为了防止重放攻击（例如第三者截获了加密的Ticket将此作为请求发送给服务器，服务器认为有效就给予了第三者访问权限），Ticket要设定一个时效性
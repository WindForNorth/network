## 一、http2的优秀之处

### 1.http1.1的主要问题

1.1高延时，主要原因：

- 延迟难以下降：延迟下降至一定数值之后就难以再下降
- 并发连接有限：浏览器对同一域名的并发连接有上限，比如谷歌对于同一域名的连接上限是6个
- 对头阻塞问题
- http头部巨大且重复：http是一个无状态协议，每个报文请求都得携带头部，特别是对于有携带 cookie 的头部，⽽ cookie 的⼤⼩通常很⼤
- 不支持服务器推送：当客户端需要获取通知时，只能通过定时器不断地拉取消息，这⽆疑浪费大量带宽和服务器资源

之前所提的优化手段实际上都不能直接对1.1进行实施，要想针对以上内容进行优化就必须要重新设计协议

### 2.兼容1.1

- 仍然⽤「http://」表示明⽂协议，⽤「https://」表示加密协议， 于是只需要浏览器和服务器在背后⾃动升级协议，用户感知不到协议的升级，实现协议的平滑升级
- 运输层还是基于TCP，将应用层的http分为了【语义】和【语法】两个层面，对于语义层面不予改动，比如请求方法、状态码、头部字段规则保持不变，但是语法层面做了很对改造

### 3.头部压缩

1.1的body部分可以使用针对性的压缩手段，但是对于header没有优化，这就导致了存在以下问题：

- 含有很多固定字段，⽐如Cookie、User Agent、Accept 等，这个字段加起来也有几百上千字节了
- ⼤量的请求和响应的报⽂⾥有很多字段值都是重复的，这样会使得⼤量带宽被这些冗余的数据占⽤了
- 字段是 ASCII 编码的，虽然易于⼈类观察，但效率低

针对以上问题，http2都解决了，针对性地开发了HPACK算法：

- 静态字典
- 动态字典
- Huffman编码

#### 3.1静态表编码

HTTP/2 为⾼频出现在头部的字符串和字段建⽴了⼀张静态表，它是写⼊到 HTTP/2 框架⾥的，不会变化的。其中使用的索引来表示特定的头部值和名称。头部中有的索引对应的值是动态的（虽然叫做动态表），这部分值都需要经过Huffman编码（这个算法将高频出现的字母使用最短的二进制编码表示）后发送；而对于静态的固定值，直接发送索引即可

根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 01 ，压缩编码后的第一个字节的后六位表示在动态表中的索引值，其后所跟字节为对应的头部值的压缩编码（不足整字节会补齐），通过查找索引表，就能确定头部信息了

#### 3.1动态编码表

对于发送过程中一些非固定的字段，每一次发送就会在客户端和服务器上的字典上添加一个索引及其值和名称，下一次再次发送时就只需直接发送索引即可。同时这个字典不能无限制地扩大，当一个连接达到限制的请求数量之后就会被关闭，释放内存资源

### 4.二进制帧

HTTP/2 厉害的地⽅在于将 HTTP/1 的⽂本格式改成⼆进制格式传输数据，极⼤提⾼了 HTTP 传输效率，⽽且⼆进 制数据使⽤位运算能⾼效解析

http/2使用两个帧来划分报文，分为头部帧和数据帧。其中头部帧有诸如帧长度（24bits）、帧类型（8bits）、标志位（8bits）、最高位R（1）、和一个流标识符（31）。流标识符用于接收方在乱序的报文中采用合理的顺序组装为原始报文。

### 5.并发传输

通过 Stream 设计，多个 Stream 复⽤⼀条 TCP 连接，达到并发的效果，解决了 HTTP/1.1 队头阻塞的问题，提⾼了 HTTP 传输的吞吐量。每个TCP连接可以有多条流，每个流可以有多条message，每条message可以包含多条frame（frame是头部和包体的组成）。因此一条http消息可以使用多条流进行乱序传输，流之间的消息可以序号打乱，但是流内部的消息必须严格有序（注意这个并发是解决了1.1里面的阻塞问题，但是并没有彻底解决对头阻塞，因为它是基于TCP协议的传输）

### 6.服务器推送

客户端发起的请求，必须使⽤的是奇数号 Stream，服务器主动的推送，使⽤的是偶数号 Stream。服务器在推送资 源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接 下来会在哪个偶数号 Stream 中发送包体
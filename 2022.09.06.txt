## 一、https的ECDHE握手解析

DH算法因为效率问题不被经常采用，因此出现了ECDHE算法。https常用的秘钥交换算法有两种，就是RSA和ECDHE算法，前者不具有前向保密，后者具备

### 1.离散对数

```
//DH算法的数学基础
a^i(mod p) = b
对于一个整数b和一个质数p，存在一个原根a，可以找到一个唯一的指数i满足上式，称i是b的以a为底的模p的离散对数，其中a和p是公开的，知道了对数i很容易计算真数p，反之则非常难，以现有的计算机计算能力在p是一个很大的质数时，知道真数想要反过来计算底数那是几乎不可能的，这就是DH算法的数学基础
```

### 2.DH算法

ECDHE算法就是从DH算法演变的。其原理如下：

- 通信双方先协商一个底数a和一个模数p，这个公开，然后各自随机生成一个整数作为其私钥（假设就是i1和i2）

- 有了上面的内容就能各自计算自己的公钥：A = a^i1(mod p)，B = a^i2(mod p)

- 交换这个两个公钥，因此这两个公钥也是公开的

- 现在通信双方各自有：a、p、A、i1、B和a、p、A、i2、B，可以计算会话使用的对称秘钥了

- 双方计算的对称秘钥都是一样的K，其中K = B^i1(mod p) = A^i2(mod p)，很神奇，但是是一样的，具体原理如下：

  ```
  K = B^i1(mod p) = (a^i2(mod p))^i1 mod p = a^i1*i2 mod p = (a^i1 mod p)^i2 mod p = A^i2 mod p = K
  ```

只要双方各自保护好自己的私钥，那么即使a、p、A、B都公开，想要根据这四个数反向计算私钥，进而计算会话秘钥那几乎是不可能的

### 3.DHE算法

有一种DH的实现是固定一方的私钥，使得每次生成的私钥都是相同的，一般是服务器，但是显然这个不安全，因此采用了每次会话都随机生成双方的私钥，就是DHE算法

### 4.ECDHE算法

利用了椭圆的某种特性，简化了计算公钥和会话秘钥的过程，大致是这样的：

- 双方协商使用的椭圆曲线，和一个基点G，两组参数都公开
- 双方生成自己的私钥d1，d2，计算出公钥：Q 1= d1G，Q2 = d2G
- 交换各自的公钥，最后计算点（x1，y1） = d1Q2，（x2，y2） = d2Q1，由于椭圆曲线 上是可以满⾜乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此双⽅的 x 坐标是⼀样的，所 以它是共享密钥，也就是会话密钥。

### 5.ECDHE握手过程

- 第一次握手：客户端发送TLS 版本号、⽀持的密码套件列表，以及⽣ 成的随机数，同RSA秘钥交换
- 第二次握手：服务器确认的 TLS 版本 号，也给出了⼀个随机数（Server Random），然后从客户端的密码套件列表选择了⼀个合适的密码套件，不过此次选择的秘钥协商算法会是ECDHE算法，不是以往的RSA，当然签名算法可能还是RSA算法；紧接着服务器会下发证书，验证自己的身份；接下来就是服务器的Server Key Exchange，服务器选定使用的椭圆伴随生成基点G、并随机生成随机数作为私钥计算出自己的公钥，将公钥使用RSA算法加密将这些信息发送非客户端
- 第三次握手：客户端验证服务器证书，无误后生成自己的椭圆曲线私钥，计算出自己的公钥，将信息共享给服务器。至此，双方拥有：自己的私钥、对方的椭圆曲线的公钥、G，因而能够计算出坐标x，且都相同，但是这个还不是会话秘钥，真正的会话秘钥是【客户端随机数+服务器随机数+ECDHE算法算出的x】生成的。接着客户发送之前数据的加密摘要，让服务器验证产生的会话秘钥是否可用
- 第四次握手：服务器也发送一个数据的摘要，用于验证客户单会话秘钥是否可用，没问题，那么握手正式完成，双方可以发送https加密报文通信了
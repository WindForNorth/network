# TCP连接断开

## 1.四次挥手

假如是客户端请求关闭链接：

- 客户端发送FIN = 1的报文，进入FIN_WAIT_1状态
- 服务器收到FIN = 1的报文，发送ACK，进入CLOSED_WAIT状态
- 客户端收到ACK，进入FIN_WAIT_2状态，此时等待服务器处理。之后服务器发送FIN = 1的报文，进入LAST_ACK状态
- 客户端收到FIN = 1的报文，返回ACK并进入TIME_WAIT。服务器收到ACK进入CLOSED状态，同时客户端在经过2MSL时间之后也进入CLOSED状态

PS：只有主动请求断开连接的一方才会有TIME_WAIT状态

## 2. 为什么需要四次而不是像建立链接一样的三次？

可以看到服务器的ACK包和FIN = 1的包如果合并就会只需要三次。但是事实并不是总是那么适时的，发送FIN = 1的报文只是意味着自己不再发送数据，但是还能接收数据。客户端发送了FIN  = 1的包之后，还能处理来自服务器的数据，此时服务器也许还有数据需要发送，所以只是象征性回复一个ACK表示这个请求断开连接的包已经收到，但是还得等我把要发送的数据全部发送完毕之后才会发送FIN = 1的包。

所以中间服务器的ACK和FIN = 1的包不能合并，从而需要四次挥手

## 3.为什么TIME_WAIT是等待2MSL？

- MSL：maximum segment lifetime，报文最大生存时间，即报文在网络中最长的生存时间，IP头部有一个TTL字段，每过一跳路由器就会减1，当TTL为0时路由器弧自动丢弃这个包，向源主机发送ICMP错误信息

2MSL就是一来一回的最大生存时间，这段时间内，也许客户端会收到来自服务器的重发的FIN = 1的包，那么此时客户端会再次发送ACK，并重新开始计时

## 4.为什么需要TIME_WAIT？

- 防止新的相同四元组连接收到旧的数据：假设客户端发送了最后的ACK包之后立即进入了CLOSED状态，而此时因为网络拥塞，导这个ACK包迟迟未能到达服务器，那么服务器会触发超时重传一个FIN = 1的包。更巧的是这时又有一个四元组和这个连接一模一样的新连接准备建立，刚一发送SYN报文就收到了一个FIN = 1的包，此时又会触发断开连接。
- 保证被动关闭链接的一方能够正确地关闭链接：就像3中所述那样，如果因为迟迟未能收到来自客户段的ACK信息，那么服务器会不断超时重传FIN = 1的包，会导致一个相同四元组的连接不能建立（而且如果这个人就是自己那才是真的悲催）。所以等待2MSL可以保证自从客户端发送ACK之后直到接收到服务器可能重传的FIN = 1的包，使得连接能够正常关闭

## 5.TCP保活机制

当一个TCP连接处于建立状态时客户端出现故障怎么办？这可能激活TCP的保活机制。

一个时间段内如果该连接一直没有进行活动就会激活保活机制，服务器每隔一段时间发送探测报文，如果发送的探测报文都没有响应那么就判断这个连接已经死亡，通知上层程序。这个激活的时间以及发送探测报文的间隔和发送报文的次数在linux系统内都是可以设置的。